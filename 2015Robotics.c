#pragma config(Motor,  port1,           RightBack,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           RightFront,    tmotorVex393, openLoop)
#pragma config(Motor,  port3,           RightTread,    tmotorVex393, openLoop)
#pragma config(Motor,  port4,           RightWheelTop, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           RightWheelBot, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           LeftWheelTop,  tmotorVex393, openLoop)
#pragma config(Motor,  port7,           LeftWheelBot,  tmotorVex393, openLoop)
#pragma config(Motor,  port8,           LeftTread,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           LeftFront,     tmotorVex393, openLoop)
#pragma config(Motor,  port10,          LeftBack,      tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Official 7201N Clacker Robot Code.

By: Matt Haidet and Nick Oyebanji

INFO
*****************

- a '2' after a variable denotes a partner controlled variable
- Only modify Pragma for changing motors


---TODO---
- Split arithmatic into variables
- Add horn
- Add Autonomous

*/


int wheelRunning = 0;
byte SHOOTING_MODE = 1;
byte COLLECTING_MODE = -1;
byte currentMode = SHOOTING_MODE;
byte currentMode2 = COLLECTING_MODE;


int getBalancedWheelSpeed(){
return 127;
}


void drive(){
	//Speed variables (use arithmetic to determine total motor speed)
	int rf = vexRT(Ch2) + vexRT(Btn7U)*50 - vexRT(Btn7D)*50 + vexRT(Btn7R)*50 - vexRT(Btn7L)*50;
	int rb = vexRT(Ch2) + vexRT(Btn7U)*50 - vexRT(Btn7D)*50 + vexRT(Btn7R)*50 - vexRT(Btn7L)*50;
	int lf = vexRT(Ch3) + vexRT(Btn7U)*50 - vexRT(Btn7D)*50 - vexRT(Btn7R)*50 + vexRT(Btn7L)*50;
	int lb = vexRT(Ch3) + vexRT(Btn7U)*50 - vexRT(Btn7D)*50 - vexRT(Btn7R)*50 + vexRT(Btn7L)*50;


	//Speed variables for partner control (use arithmetic to determine total motor speed)
	int rf2 = vexRT(Ch2Xmtr2) + vexRT(Btn7UXmtr2)*50 - vexRT(Btn7DXmtr2)*50 + vexRT(Btn7RXmtr2)*50 - vexRT(Btn7LXmtr2)*50;
	int rb2 = vexRT(Ch2Xmtr2) + vexRT(Btn7UXmtr2)*50 - vexRT(Btn7DXmtr2)*50 + vexRT(Btn7RXmtr2)*50 - vexRT(Btn7LXmtr2)*50;
	int lf2 = vexRT(Ch3Xmtr2) + vexRT(Btn7UXmtr2)*50 - vexRT(Btn7DXmtr2)*50 - vexRT(Btn7RXmtr2)*50 + vexRT(Btn7LXmtr2)*50;
	int lb2 = vexRT(Ch3Xmtr2) + vexRT(Btn7UXmtr2)*50 - vexRT(Btn7DXmtr2)*50 - vexRT(Btn7RXmtr2)*50 + vexRT(Btn7LXmtr2)*50;


	//Motor Speed Declarations
	motor[RightFront] = (rf*currentMode) + (rf2*currentMode2);
	motor[RightBack] = (rb*currentMode) + (rb2*currentMode2);
	motor[LeftFront] = (lf*currentMode) + (lf2*currentMode2);
	motor[LeftBack] = (lb*currentMode) + (lb2*currentMode2);

}



void checkMode(){
	if(vexRT(Btn5U) == 1){
		currentMode = SHOOTING_MODE;
		} else if(vexRT(Btn5D) == 1){
		currentMode = COLLECTING_MODE;
	}
	if(vexRT(Btn5UXmtr2) == 1){
		currentMode2 = SHOOTING_MODE;
		} else if(vexRT(Btn5DXmtr2) == 1){
		currentMode2 = COLLECTING_MODE;
	}

}

void tread(){
	motor[RightTread] = (-vexRT(Btn6U)*127 + vexRT(Btn6D)*127) + (-vexRT(Btn6UXmtr2)*127 + vexRT(Btn6DXmtr2)*127);
	motor[LeftTread] = (-vexRT(Btn6U)*127 + vexRT(Btn6D)*127) + (-vexRT(Btn6UXmtr2)*127 + vexRT(Btn6DXmtr2)*127);
}


void wheel(){
	if(vexRT(Btn8D) || vexRT(Btn8DXmtr2)){
		wheelRunning = 0;
	}
	if(vexRT(Btn8U) || vexRT(Btn8UXmtr2)){
		wheelRunning = getBalancedWheelSpeed();
	}
	motor[RightWheelTop] =  wheelRunning + vexRT(Btn8R)*127 + vexRT(Btn8RXmtr2)*127;
	motor[RightWheelBot] = wheelRunning + vexRT(Btn8R)*127 + vexRT(Btn8RXmtr2)*127;
	motor[LeftWheelTop] = wheelRunning + vexRT(Btn8R)*127 + vexRT(Btn8RXmtr2)*127;
	motor[LeftWheelBot] = wheelRunning + vexRT(Btn8R)*127 + vexRT(Btn8RXmtr2)*127;
}

void autonomous(){

}


task main()
{
	while(true){
		checkMode();
		drive();
		tread();
		wheel();
	}
}
