#pragma config(Sensor, in1,    selector,       sensorAnalog)
#pragma config(Motor,  port1,           backLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rightLift1,    tmotorVex393, openLoop)
#pragma config(Motor,  port4,           rightLift2,    tmotorVex393, openLoop)
#pragma config(Motor,  port5,           liftClaw1,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           leftLift2,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           leftLift1,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           frontRight,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          backRight,     tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*TODO:

1. Replace repeated code with functions if possible
2. Write encoder functions
3. make sure functions are consitent
4. Add lateral move for time and distance
5. Move actual automonous to a seperate file
6. Make time functions actual go for Seconds rather than milis (multiple 1msec by 1000)

*/


//linear:  straight  forward, backward in any direction
void linearMove(int power){
	LEFT_BACK =	power;
	RIGHT_BACK = power;
	LEFT_FRONT = power;
	RIGHT_FRONT = power;
	wait1Msec(1000);
}

//lift arm function for the robot
void liftArm(const string direction, int power, int time) {
	if(direction == "up") {
		RIGHT_LIFT_MOTOR1 = -power;
		RIGHT_LIFT_MOTOR2 = -power;
		LEFT_LIFT_MOTOR1 = -power;
		LEFT_LIFT_MOTOR2 = -power;
}
	if(direction == "down") {
	  RIGHT_LIFT_MOTOR1 = -power;
		RIGHT_LIFT_MOTOR2 = -power;
		LEFT_LIFT_MOTOR1 = -power;
		LEFT_LIFT_MOTOR2 = -power;
	}
	wait1Msec(time);
		RIGHT_LIFT_MOTOR1 = 0;
		RIGHT_LIFT_MOTOR2 = 0;
		LEFT_LIFT_MOTOR1 = 0;
		LEFT_LIFT_MOTOR2 = 0;
}

//lift claw function for the claw
void controlClaw(const string direction, int power, int time) {
	if(direction == "up") {
		LIFT_CLAW_MOTOR1  = power;
		LEFT_LIFT_MOTOR2 = power;
	}
	if(direction == "down") {
		LIFT_CLAW_MOTOR1  = -power;
		LEFT_LIFT_MOTOR2 = -power;
	}
	wait1Msec(time);
		LIFT_CLAW_MOTOR1 = 0;
    LIFT_CLAW_MOTOR2 = 0;
}

//lateral move will decide in which direction the robot will go(left and right)
void lateralMove(const string direction, int power) {
	if(direction == "left") {
		LEFT_FRONT = -power;
		LEFT_BACK = power;
		RIGHT_FRONT = power;
		RIGHT_BACK = -power;
	}
	if(direction == "right") {
		LEFT_FRONT = power;
		LEFT_BACK = -power;
		RIGHT_FRONT = -power;
		RIGHT_BACK = power;
	}
	wait1Msec(1000);
		LEFT_FRONT = 0;
		LEFT_BACK = 0;
		RIGHT_FRONT = 0;
		RIGHT_BACK = 0;
}

void turnInPlace(const string direction, int power){
	if(direction == "right"){
		LEFT_FRONT = -power;
		LEFT_BACK = power;
		RIGHT_FRONT = power;
		RIGHT_BACK = -power;
	}
	if (direction ==  "left") {
		LEFT_BACK =	-power;
		RIGHT_BACK = power;
		LEFT_FRONT = power;
		RIGHT_FRONT = -power;
	}

}

void forwardTime(int power, int mSecs) {
	linearMove(power);
	wait1Msec(mSecs);
	linearMove(0);
}

void backwardTime(int power, int mSecs) {
	linearMove(-power);
	wait1Msec(mSecs);
	linearMove(0);
}

void leftMoveTime(int power, int mSecs) {
	lateralMove("left", power);
	wait1Msec(mSecs);
	linearMove(0);
}

void rightMoveTime(int power, int mSecs) {
	lateralMove("right", power);
	wait1Msec(mSecs);
	linearMove(0);
}

void turnRightTime(int power, int mSecs) {
	//	turnInPlace(right, 70);
}


void turnForSeconds(const string direction,int power, float seconds){

	if(direction == "right") {
		LEFT_BACK = -power;
		LEFT_FRONT = -power;
		RIGHT_FRONT = power;
		RIGHT_BACK = power;
		}
 if(direction == "left") {
		LEFT_BACK = power;
		LEFT_FRONT = power;
		RIGHT_FRONT = -power;
		RIGHT_BACK = -power;
	}
	wait1Msec(1000);
		LEFT_BACK = 0;
		LEFT_FRONT = 0;
		RIGHT_FRONT = 0;
		RIGHT_BACK = 0;
}

void moveInLineForSeconds(const string direction, int power){

}



void turnDegrees(const string direction, float degrees, int power){

	turnInPlace(direction, power);
	//while(SensorValue[

}

void turnDegrees(const string direction, float degrees, int power){

}

void moveInLineForSeconds(const string direction, int power){


}

void waitForTruth(bool truth){
	while(!truth){
		wait1Msec(1);
	}

}


//Autonomous Programs

void blueRight(){
	backwardTime(50, 400);
	liftArm("up", 100, 2000);
	forwardTime(40, 490);
	controlClaw("down" , 50, 2000);
	backwardTime(50, 500);

}

void blueLeft(){
		backwardTime(80, 700);
		lateralMove("right", 90);
		//controlClaw("down", 60, 400);
		forwardTime(40, 100);
		lateralMove("left", 500);
		forwardTime(100, 600);
		backwardTime(80, 300);

}

void redRight(){
  forwardTime(90, 500);
  controlClaw("up", 90, 500);
  backwardTime(90, 300);
  controlClaw("down",  50, 200);
  lateralMove("left", 90, 400);
  forwardTime(90, 300);
  controlClaw("up", 70, 150);
  backwardTime(80, 300);
}

void redLeft(){
controlClaw("down", 80, 300);
backwardTime(90, 500);
lateralMove("right", 80, 400);
forwardTime(90, 500);
turnForSeconds("right", 80, 5.0);

}

void challenge(){

}
